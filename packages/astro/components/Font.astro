---
import * as mod from 'virtual:astro:assets/fonts/internal';
import { AstroError, AstroErrorData } from '../dist/core/errors/index.js';

// TODO: remove check when fonts are stabilized
const { internalConsumableMap } = mod;
if (!internalConsumableMap) {
	throw new AstroError(AstroErrorData.ExperimentalFontsNotEnabled);
}

interface Props {
	/** The `cssVariable` registered in your Astro configuration. */
	cssVariable: import('astro:assets').CssVariable;
	/** Whether it should output [preload links](https://web.dev/learn/performance/optimize-web-fonts#preload) or not. */
	preload?: boolean | Array<{ weight?: string | number; style?: string; subset?: string }>;
}

const { cssVariable, preload = false } = Astro.props as Props;
const data = internalConsumableMap.get(cssVariable);
if (!data) {
	throw new AstroError({
		...AstroErrorData.FontFamilyNotFound,
		message: AstroErrorData.FontFamilyNotFound.message(cssVariable),
	});
}

const filteredPreloadData = preload
	? preload === true
		? // Preload everything
			data.preloadData
		: // Only preload urls based on weight, style and subset
			data.preloadData.filter(({ weight, style, subset }) =>
				preload.some(
					(p) =>
						// Always check the weight
						(!p.weight || p.weight.toString() === weight) &&
						// Only check the style if specified
						(!p.style || p.style === style) &&
						// Only check the subset if specified
						(p!.subset || p.subset === subset),
				),
			)
	: null;
---

{
	filteredPreloadData &&
		filteredPreloadData.map(({ url, type }) => (
			<link rel="preload" href={url} as="font" type={`font/${type}`} crossorigin />
		))
}
<style set:html={data.css}></style>
